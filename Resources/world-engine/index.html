<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>World Engine</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div id="instructions">
        <h1>Controls</h1>
        <p>Move: <strong>W A S D</strong></p>
        <p>Jump: <strong>Space</strong></p>
        <p>Look: <strong>Mouse</strong></p>
    </div>

    <div id="chat_overlay" aria-label="World Engine chat">
        <div id="chat_log" aria-live="polite"></div>
        <form id="chat_form" autocomplete="off">
            <input id="chat_input" name="chat_input" type="text" placeholder="Type a message..." inputmode="text" maxlength="1000">
            <button type="submit" aria-label="Send Message">Send</button>
        </form>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ExpressionTextureClient } from './dist/expression-listener.js';

        const DEFAULT_CHAT_MESSAGE = 'The river looks peaceful today...';
        const ASSISTANT_MESSAGE_EVENT = 'world-engine-assistant-message';
        const CHAT_SPRITE_OFFSET = new THREE.Vector3(0, 2.6, 0); 
        const CHAT_HISTORY_LIMIT = 12;
        const CHAT_WORLD_WIDTH = 7;
        const PLAYER_EYE_HEIGHT = 1.7;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 11.0;
        
        // World Config
        const WORLD_SIZE = 200;
        const TIME_SCALE = 0.5;

        const runtimeSettings = {
            movementSpeed: 1.0,
            invertLook: false,
            showInstructions: true,
        };

        const state = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            jump: false,
            isGrounded: true,
            velocity: new THREE.Vector3(),
            yaw: Math.PI,
            pitch: 0,
            lastTime: performance.now(),
            isLocked: false,
            isChatFocused: false,
            chatText: DEFAULT_CHAT_MESSAGE,
            chatHistory: [],
            globalTime: 0,
        };

        let camera, scene, renderer;
        let chatMaterial, chatSprite, avatarSprite;
        let expressionClient;
        let chatInput, chatForm;
        let fireflies;
        
        // Global Uniforms for Wind
        const globalUniforms = {
            time: { value: 0 },
            windStrength: { value: 0.15 },
            windDirection: { value: new THREE.Vector3(1.0, 0, 0.5).normalize() }
        };

        window.WorldEngine = window.WorldEngine || {};
        window.WorldEngine.updateChatMessage = updateChatMessage;
        window.WorldEngine.applySettings = applySettings;
        window.WorldEngine.ExpressionTextureClient = ExpressionTextureClient;
        window.WorldEngine.receiveAssistantMessage = (message) => recordChatMessage('assistant', message);

        window.addEventListener(ASSISTANT_MESSAGE_EVENT, (event) => {
            const incoming = event?.detail?.message ?? event?.detail ?? '';
            recordChatMessage('assistant', incoming);
        });

        window.addEventListener('message', handleIncomingMessage);

        init();
        animate();

        function init() {
            parseSettingsFromQuery();

            scene = new THREE.Scene();
            // Sky color from reference (Bright Blue)
            scene.background = new THREE.Color(0x68aaff);
            // Fog to blend distant trees
            scene.fog = new THREE.FogExp2(0x68aaff, 0.018);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.rotation.order = 'YXZ';
            camera.rotation.set(state.pitch, state.yaw, 0, 'YXZ');
            
            // Start player on the river bank
            const startY = getTerrainHeight(0, 15) + PLAYER_EYE_HEIGHT;
            camera.position.set(0, startY, 15);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xcce0ff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfff8e0, 1.3);
            sunLight.position.set(50, 80, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            const d = 80;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.bias = -0.0005;
            scene.add(sunLight);

            // Backlight for rim effect
            const backLight = new THREE.DirectionalLight(0x445588, 0.4);
            backLight.position.set(-30, 20, -50);
            scene.add(backLight);

            buildWorld();
            buildAvatar();

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            
            document.body.appendChild(renderer.domElement);

            setupPointerLock(renderer.domElement);
            setupEvents();
            setupChatUi();
            updateInstructionsVisibility();
        }

        // --- SHADERS ---

        // Inject wind logic into standard materials
        function makeWindMaterial(color) {
            const mat = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                flatShading: true, // Stylized look
            });

            mat.onBeforeCompile = (shader) => {
                shader.uniforms.time = globalUniforms.time;
                shader.uniforms.windStrength = globalUniforms.windStrength;
                
                shader.vertexShader = `
                    uniform float time;
                    uniform float windStrength;
                    ${shader.vertexShader}
                `;
                
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    
                    // Simple Wind Logic
                    // Bend x and z based on y height
                    float windFactor = max(0.0, position.y - 0.5);
                    float sway = sin(time * 1.5 + position.x * 0.5 + position.z * 0.5) * 0.1;
                    float sway2 = cos(time * 2.0 + position.x * 0.3) * 0.05;
                    
                    transformed.x += (sway + sway2) * windFactor * windStrength;
                    transformed.z += (sway - sway2) * windFactor * windStrength;
                    `
                );
            };
            
            // Make it a unique instance so uniforms bind correctly
            return mat;
        }

        // --- Terrain Math ---

        function getTerrainHeight(x, z) {
            // Base rolling hills
            const hill = (Math.sin(x * 0.04) + Math.cos(z * 0.04)) * 2.0;
            
            // River Channel (carve a path along X axis roughly)
            // We want a river flowing roughly along Z=0 to Z=20 area? 
            // Let's make it wind a bit.
            const riverPath = Math.sin(x * 0.05) * 10; 
            const distToRiver = Math.abs(z - riverPath);
            
            let height = hill + 3.0; // Base height
            
            // Carve river
            if (distToRiver < 12.0) {
                // Smooth carving
                const depth = Math.cos(distToRiver * 0.15) * 5.0;
                height -= Math.max(0, depth);
            }
            
            return height;
        }

        function buildWorld() {
            // 1. Terrain
            const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 128, 128);
            geo.rotateX(-Math.PI / 2);
            const pos = geo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                pos.setY(i, getTerrainHeight(x, z));
            }
            geo.computeVertexNormals();
            
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x4caf50, 
                roughness: 1,
                flatShading: false // Smooth terrain like reference
            });
            const terrain = new THREE.Mesh(geo, groundMat);
            terrain.receiveShadow = true;
            scene.add(terrain);

            // 2. Water Plane
            const waterGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            waterGeo.rotateX(-Math.PI / 2);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x3366ff,
                transparent: true,
                opacity: 0.75,
                roughness: 0.1,
                metalness: 0.2
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.y = 0.5; // Water Level
            scene.add(water);

            // 3. Scenery
            buildVegetation();
            buildRuins();
            buildFireflies();
        }

        function buildVegetation() {
            // -- Instanced Grass --
            const grassGeo = new THREE.PlaneGeometry(0.3, 0.8);
            grassGeo.translate(0, 0.4, 0);
            const grassMat = makeWindMaterial(0x88cc44);
            grassMat.side = THREE.DoubleSide;
            
            const grassCount = 8000;
            const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
            grassMesh.receiveShadow = true;
            grassMesh.castShadow = false; // Too expensive
            
            const dummy = new THREE.Object3D();
            let grassIdx = 0;
            
            // -- Trees --
            const trunkGeo = new THREE.CylinderGeometry(0.6, 0.8, 3, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
            
            const foliageGeo = new THREE.ConeGeometry(3.5, 5, 7);
            const foliageMat = makeWindMaterial(0x2d6e32); // Darker pine green
            
            // Rocks
            const rockGeo = new THREE.DodecahedronGeometry(1.0, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x888888, flatShading: true });

            for (let i = 0; i < 60; i++) {
                const x = (Math.random() - 0.5) * 160;
                const z = (Math.random() - 0.5) * 160;
                const y = getTerrainHeight(x, z);

                // Don't spawn underwater or too close to spawn
                if (y < 1.0 || (Math.abs(x) < 5 && Math.abs(z-15) < 5)) {
                    continue;
                }

                // Spawn Grass Clumps
                if (Math.random() > 0.3 && grassIdx < grassCount - 50) {
                    for (let g=0; g<40; g++) {
                        const gx = x + (Math.random() - 0.5) * 10;
                        const gz = z + (Math.random() - 0.5) * 10;
                        const gy = getTerrainHeight(gx, gz);
                        if (gy > 0.6) {
                            dummy.position.set(gx, gy, gz);
                            dummy.rotation.y = Math.random() * Math.PI;
                            dummy.rotation.x = (Math.random() - 0.5) * 0.3;
                            dummy.scale.setScalar(0.8 + Math.random() * 0.6);
                            dummy.updateMatrix();
                            grassMesh.setMatrixAt(grassIdx++, dummy.matrix);
                        }
                    }
                }
                
                // Spawn Trees (Tall Pines)
                if (Math.random() > 0.6) {
                    const treeGroup = new THREE.Group();
                    treeGroup.position.set(x, y, z);
                    
                    // Scale varies height
                    const scale = 1.0 + Math.random() * 0.8;
                    
                    // Trunk
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 1.5;
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    treeGroup.add(trunk);

                    // 3 Layers of foliage high up
                    for(let L=0; L<3; L++) {
                        const f = new THREE.Mesh(foliageGeo, foliageMat);
                        f.position.y = 4.0 + (L * 2.5);
                        const s = 1.2 - (L * 0.2);
                        f.scale.set(s, 1, s);
                        f.castShadow = true;
                        f.receiveShadow = true;
                        treeGroup.add(f);
                    }

                    treeGroup.scale.set(scale, scale, scale);
                    // Random rotation
                    treeGroup.rotation.y = Math.random() * Math.PI;
                    scene.add(treeGroup);
                }
                
                // Spawn Rocks near water
                if (y < 2.5 && Math.random() > 0.5) {
                    const rock = new THREE.Mesh(rockGeo, rockMat);
                    rock.position.set(x, y + 0.2, z);
                    rock.scale.setScalar(0.5 + Math.random());
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    scene.add(rock);
                }
            }
            scene.add(grassMesh);
        }

        function buildRuins() {
            // Broken Bridge pieces over the river
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
            
            // Bridge 1 part
            const plank = new THREE.BoxGeometry(4, 0.2, 1);
            const group1 = new THREE.Group();
            
            const p1 = new THREE.Mesh(plank, woodMat);
            p1.castShadow = true;
            group1.add(p1);
            
            const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), woodMat);
            post.position.set(1.8, 0.5, 0.4);
            group1.add(post);
            const post2 = post.clone();
            post2.position.set(-1.8, 0.5, -0.4);
            group1.add(post2);

            // Place broken bridge in river
            group1.position.set(10, 1.0, 5); // Positioned to look like it fell
            group1.rotation.z = 0.2;
            group1.rotation.y = 0.5;
            scene.add(group1);
            
            const group2 = group1.clone();
            group2.position.set(6, 1.2, 3);
            group2.rotation.z = -0.1;
            group2.rotation.y = 0.4;
            scene.add(group2);

            // Spawn Podium (Old Stone)
            const podiumGeo = new THREE.CylinderGeometry(3, 3.5, 0.5, 8);
            const podiumMat = new THREE.MeshStandardMaterial({ color: 0x777777, flatShading: true });
            const podium = new THREE.Mesh(podiumGeo, podiumMat);
            
            // Find ground height for spawn
            const spawnH = getTerrainHeight(0, 15);
            podium.position.set(0, spawnH + 0.25, 15);
            podium.receiveShadow = true;
            scene.add(podium);
            
            // Move avatar to podium
            avatarSprite.position.set(0, spawnH + 2.5, 15);
        }

        function buildFireflies() {
            const count = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const phases = [];

            for(let i=0; i<count; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    1 + Math.random() * 5,
                    (Math.random() - 0.5) * 100
                );
                phases.push(Math.random() * Math.PI * 2);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

            const material = new THREE.PointsMaterial({
                color: 0xaaffaa, // Greenish magical look
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            fireflies = new THREE.Points(geometry, material);
            scene.add(fireflies);
        }

        function buildAvatar() {
            const textureLoader = new THREE.TextureLoader();
            const material = new THREE.SpriteMaterial({ transparent: true });
            avatarSprite = new THREE.Sprite(material);
            avatarSprite.scale.set(3, 3, 1);
            // Position set in buildRuins to match podium
            scene.add(avatarSprite);

            expressionClient = new ExpressionTextureClient({ sprite: avatarSprite, textureLoader });
            if (expressionClient?.fallbackUrl) expressionClient.swapTexture(expressionClient.fallbackUrl);

            chatMaterial = new THREE.SpriteMaterial({ transparent: true, depthTest: false, depthWrite: false });
            chatSprite = new THREE.Sprite(chatMaterial);
            chatSprite.renderOrder = 10;
            // Initial position, updated in loop
            chatSprite.scale.set(CHAT_WORLD_WIDTH, 3.5, 1);
            scene.add(chatSprite);
        }

        // --- Chat System (Same as before) ---
        function updateChatMessage(message, role = 'assistant') { recordChatMessage(role, message); }
        function recordChatMessage(role, message) {
            const normalizedRole = role === 'user' ? 'user' : 'assistant';
            const text = String(message ?? '').trim() || DEFAULT_CHAT_MESSAGE;
            const history = state.chatHistory;
            history.push({ role: normalizedRole, text });
            if (history.length > CHAT_HISTORY_LIMIT) history.shift();
            renderChatBubble();
        }

        function renderChatBubble() {
            if (!chatMaterial) return;
            if (chatMaterial.map) chatMaterial.map.dispose();

            const assistantMsgs = state.chatHistory.filter(m => m.role === 'assistant');
            const displayEntry = assistantMsgs.length ? assistantMsgs[assistantMsgs.length - 1] : null;
            const entries = displayEntry ? [displayEntry] : (state.chatHistory.length === 0 ? [{role:'assistant', text:DEFAULT_CHAT_MESSAGE}] : []);
            
            if (entries.length === 0) { chatSprite.visible = false; return; }
            
            chatSprite.visible = true;
            const { texture, aspectRatio } = createChatTexture(entries);
            chatMaterial.map = texture;
            chatMaterial.needsUpdate = true;
            
            const newHeight = CHAT_WORLD_WIDTH / aspectRatio;
            chatSprite.scale.set(CHAT_WORLD_WIDTH, newHeight, 1);
            // Adjust y position logic in animate loop
            chatSprite.userData.height = newHeight;
        }

        function createChatTexture(historyEntries) {
            const entry = historyEntries[0];
            const padding = 40, headerHeight = 60, lineHeight = 44, canvasWidth = 1024;
            const maxWidth = canvasWidth - (padding * 2);
            const tailHeight = 30;

            const mCanvas = document.createElement('canvas');
            const mCtx = mCanvas.getContext('2d');
            mCtx.font = '500 32px "Inter", "Segoe UI", system-ui, sans-serif';
            const wrappedLines = wrapText(mCtx, entry.text, maxWidth);
            const totalHeight = padding + headerHeight + (wrappedLines.length * lineHeight) + padding + tailHeight;

            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = Math.max(256, totalHeight);
            const ctx = canvas.getContext('2d');

            const bubbleHeight = canvas.height - tailHeight - 20;
            const startX = 10, startY = 10; 

            const gradient = ctx.createLinearGradient(0, 0, 0, bubbleHeight);
            gradient.addColorStop(0, 'rgba(25, 35, 50, 0.95)');
            gradient.addColorStop(1, 'rgba(15, 20, 30, 0.98)');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 4;
            ctx.shadowColor = 'rgba(0,0,0,0.7)';
            ctx.shadowBlur = 25;
            ctx.shadowOffsetY = 15;
            
            roundRect(ctx, startX, startY, canvas.width - 20, bubbleHeight, 40, true, true);
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;

            ctx.beginPath();
            const tailX = canvas.width / 2;
            const tailYPos = startY + bubbleHeight;
            ctx.moveTo(tailX - 25, tailYPos);
            ctx.lineTo(tailX, tailYPos + tailHeight);
            ctx.lineTo(tailX + 25, tailYPos);
            ctx.fillStyle = 'rgba(15, 20, 30, 0.98)';
            ctx.fill();

            ctx.font = 'bold 28px "Inter", sans-serif';
            ctx.fillStyle = '#60a5fa';
            ctx.textBaseline = 'top';
            ctx.fillText("ASSISTANT", startX + padding, startY + padding);

            ctx.font = '500 32px "Inter", sans-serif';
            ctx.fillStyle = '#f1f5f9';
            let textY = startY + padding + headerHeight;
            wrappedLines.forEach(line => { ctx.fillText(line, startX + padding, textY); textY += lineHeight; });

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;
            return { texture, aspectRatio: canvas.width / canvas.height };
        }
        
        function wrapText(ctx, message, maxWidth) {
            const words = message.split(/\s+/);
            let lines = [];
            let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                const width = ctx.measureText(currentLine + " " + words[i]).width;
                if (width < maxWidth) currentLine += " " + words[i];
                else { lines.push(currentLine); currentLine = words[i]; }
            }
            lines.push(currentLine);
            return lines;
        }

        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
            ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.closePath();
            if (fill) ctx.fill(); if (stroke) ctx.stroke();
        }

        // --- System & Physics ---
        function parseSettingsFromQuery() {
            const params = new URLSearchParams(window.location.search);
            applySettings({
                movementSpeed: Number(params.get('moveSpeed')) || 1.0,
                invertLook: params.get('invertLook') === 'true',
                showInstructions: params.get('showInstructions') === 'true',
            });
        }

        function applySettings(newSettings = {}) {
            runtimeSettings.movementSpeed = Math.max(0.1, Number(newSettings.movementSpeed ?? runtimeSettings.movementSpeed));
            runtimeSettings.invertLook = Boolean(newSettings.invertLook ?? runtimeSettings.invertLook);
            runtimeSettings.showInstructions = Boolean(newSettings.showInstructions ?? runtimeSettings.showInstructions);
            updateInstructionsVisibility();
        }

        function handleIncomingMessage(event) {
            if (event.data?.source !== 'world-engine') return;
            if (event.data.type === 'world-engine-settings') applySettings(event.data.payload);
            if (event.data.type === 'world-engine-chat') {
                if (Array.isArray(event.data.payload?.history)) replaceChatHistory(event.data.payload.history);
                else if (event.data.payload?.direction !== 'outgoing') recordChatMessage(event.data.payload?.role || 'assistant', event.data.payload?.text);
            }
        }
        
        function setupPointerLock(target) {
            const requestLock = () => target.requestPointerLock?.();
            document.getElementById('instructions')?.addEventListener('click', requestLock);
            target.addEventListener('click', requestLock);
            document.addEventListener('pointerlockchange', () => {
                state.isLocked = document.pointerLockElement === target;
                updateInstructionsVisibility();
            });
            document.addEventListener('mousemove', (e) => {
                if (!state.isLocked) return;
                state.yaw -= e.movementX * 0.0025;
                state.pitch -= e.movementY * 0.0025 * (runtimeSettings.invertLook ? -1 : 1);
                state.pitch = Math.max(-1.5, Math.min(1.5, state.pitch));
                camera.rotation.set(state.pitch, state.yaw, 0, 'YXZ');
            });
        }
        
        function setupChatUi() {
            chatInput = document.getElementById('chat_input');
            chatForm = document.getElementById('chat_form');
            chatForm?.addEventListener('submit', (e) => {
                e.preventDefault();
                const text = chatInput?.value?.trim();
                if (text) { dispatchChatMessage(text); chatInput.value = ''; chatInput.blur(); }
            });
            chatInput?.addEventListener('focus', () => { state.isChatFocused = true; state.moveForward=state.moveBackward=state.moveLeft=state.moveRight=false; if(document.pointerLockElement) document.exitPointerLock(); });
            chatInput?.addEventListener('blur', () => state.isChatFocused = false);
            renderChatBubble();
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            document.addEventListener('keydown', (e) => handleKey(e, true));
            document.addEventListener('keyup', (e) => handleKey(e, false));
        }
        
        function handleKey(e, pressed) {
            if (state.isChatFocused) {
                if(e.code === 'Enter' && pressed) chatInput.focus();
                if(e.code === 'Escape' && pressed) chatInput.blur();
                return;
            }
            switch(e.code) {
                case 'ArrowUp': case 'KeyW': state.moveForward = pressed; break;
                case 'ArrowLeft': case 'KeyA': state.moveLeft = pressed; break;
                case 'ArrowDown': case 'KeyS': state.moveBackward = pressed; break;
                case 'ArrowRight': case 'KeyD': state.moveRight = pressed; break;
                case 'Space': state.jump = pressed; break;
            }
        }

        function dispatchChatMessage(text) {
            recordChatMessage('user', text);
            window.parent?.postMessage({ source: 'world-engine', type: 'world-engine-chat', payload: { text, role: 'user', direction: 'outgoing' } }, '*');
        }

        function replaceChatHistory(entries = []) {
            const normalized = Array.isArray(entries) ? entries.map(entry => ({
                role: entry?.role === 'user' ? 'user' : 'assistant',
                text: String(entry?.text ?? '').trim()
            })).filter(entry => entry.text) : [];
            state.chatHistory = normalized.slice(-CHAT_HISTORY_LIMIT);
            renderChatBubble();
        }
        
        function updateInstructionsVisibility() {
            const el = document.getElementById('instructions');
            if(el) el.style.display = (runtimeSettings.showInstructions && !state.isLocked) ? 'block' : 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - state.lastTime) / 1000, 0.1); // Cap delta
            state.lastTime = time;
            state.globalTime += delta;

            // Update Wind Uniforms
            globalUniforms.time.value = state.globalTime;

            // Firefly Motion
            if(fireflies) {
                const pos = fireflies.geometry.attributes.position.array;
                const ph = fireflies.geometry.attributes.phase.array;
                for(let i=0; i<pos.length/3; i++) {
                    pos[i*3+1] += Math.sin(state.globalTime * 1.0 + ph[i]) * 0.02; // Vertical bob
                    pos[i*3] += Math.cos(state.globalTime * 0.5 + ph[i]) * 0.01; // Horizontal drift
                }
                fireflies.geometry.attributes.position.needsUpdate = true;
            }

            // Physics
            if (state.isLocked) updateMovement(delta);

            // Chat Bubble Tracking
            if (chatSprite && chatSprite.visible) {
                const bob = Math.sin(state.globalTime * 2.0) * 0.05;
                const h = chatSprite.userData.height || 3.5;
                // Match avatar position + offset
                chatSprite.position.copy(avatarSprite.position).add(CHAT_SPRITE_OFFSET);
                chatSprite.position.y += (h * 0.4) + bob; 
                chatSprite.lookAt(camera.position);
            }

            renderer.render(scene, camera);
        }

        function updateMovement(delta) {
            const damping = 8.0; 
            const accel = 60.0 * runtimeSettings.movementSpeed;

            state.velocity.x -= state.velocity.x * damping * delta;
            state.velocity.z -= state.velocity.z * damping * delta;

            const inputX = Number(state.moveRight) - Number(state.moveLeft);
            const inputZ = Number(state.moveBackward) - Number(state.moveForward);

            if (inputX !== 0 || inputZ !== 0) {
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.yaw);
                const move = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, -inputZ).normalize();
                state.velocity.x += move.x * accel * delta;
                state.velocity.z += move.z * accel * delta;
            }
            
            state.velocity.y -= GRAVITY * delta;
            if (state.jump && state.isGrounded) {
                state.velocity.y = JUMP_FORCE;
                state.isGrounded = false;
            }

            camera.position.x += state.velocity.x * delta;
            camera.position.z += state.velocity.z * delta;
            camera.position.y += state.velocity.y * delta;

            const groundH = getTerrainHeight(camera.position.x, camera.position.z);
            if (camera.position.y < groundH + PLAYER_EYE_HEIGHT) {
                camera.position.y = groundH + PLAYER_EYE_HEIGHT;
                state.velocity.y = Math.max(0, state.velocity.y);
                state.isGrounded = true;
            } else {
                state.isGrounded = false;
            }
        }
    </script>
</body>
</html>
